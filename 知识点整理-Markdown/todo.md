
```
3.1 数据结构

    线性表：顺序存储[地址连续的存储单元]、链式存储[指针链接]
    栈：先进后出[LIFO]    Last In, First Out
    队列：先进先出[FIFO]
    {
        环状队列：队满[(tail + 1) % capacity == head]、队空[head = tail]、初始状态[head = tail = 0]
                    队尾指针所指位置的下一个位置是队头指针
        双端队列：同时拥有栈和队列的特性；用途：窗口抖动算法、撤销/重做、任务调度、回文检查、LRU Cache变种
        {
            示例计算：
                初始队列: []
                pushA(1) → [1]
                pushB(2) → [1, 2]
                pushA(3) → [3, 1, 2]
                popB()   → 移除2，剩余 [3, 1]
        }
    }
    串：空串[长度为0，不包含任何字符串]、空格串[一个或者多个的空格]、子串[任何长度连续构成，空串也算]

    二维数组：由固定行数(m)和列数(n)组成的矩阵结构，每个元素通过a[i][j]访问
    树：
    {
        概念：根节点；双亲，兄弟、孩子节点；节点的度；叶子节点[没有子节点]、内部节点[除去根节点，叶子节点之外的节点]、树的深度
        * 叶子节点：没有子节点的节点（即度为0的节点）
        * 高度 = 最大层数 - 1
        二叉树：
            1.满二叉树：总节点为[2^k - 1]，层数最多有[2 ^ (k-1)]节点； 注：k为层数/深度
            2.完全二叉树：[h-1层]节点全满；[h层]节点从左到右没有留空即完全
            3.具有N个节点树的深度/层级 [log2N + 1]
            4.二叉树的链式存储：二叉链表[左右指针指向左右节点]、三叉链表；[三叉链表，在二叉链表的基础上多加了一个指向父节点的指针域，查询方便]

        二叉树的遍历：
            1.前序遍历：[根-左-右]  1-2-4-5-7-8-3-6  [拆分左右,自上而下]  
            2.中序遍历：[左-跟-右]  4-2-7-8-5-1-3-6  [看成整体、递归]
            3.后序遍历：[左-右-跟]  4-8-7-5-2-6-3-1  [看成整体、递归]
            4.层次遍历：[顺序存储]  1-2-3-4-5-6-7-8  [自上而下,从左到右]

        哈夫曼树：最优二叉树，带权路径长度最短的二叉树 [权值大的靠近根节点，权值小的远离]  |   数据压缩和数据编码实现最高效率
        {   
            示例计算：给定权值[5,9,12,16,18]

            1'构建哈夫曼树节点，权值最小的两个节点合并，生成一个新节点（权值为两者之和），直到剩余一棵树
                5  + 9 = 14                     60
               12 + 14 = 26                 26      34
               16 + 18 = 34               12  14  16  18     [较小的权值放在左子树]
               26 + 34 = 60                  5  9

            2'提取叶子节点，[12,5,9,16,18]

            3'计算 WPL[Weighted Path Length] = ∑(权值×边数?)  [边数 = 层数-1]

                5*3 + 9*3 + 12*2 + 16*2 + 18*2 = 134  
        }
    }
    图：是有顶点集V和边E组成 G=(V,E)，分为有向图和无向图
    {
        邻接矩阵：
        邻接图：为每一个订单创建一个单链表

        图的遍历：
            1.DFS深度优先遍历   0-1-3-2   场景：迷宫问题 [探索所有可能性，空间效率高]
            2.BFS广度优先遍历   0-1-2-3   场景：最短路径 [最短路径，时间效率高]
        
                0
               / \
              1---2
               \ /
                3
    }
```


```
3.2 数据运算

    查找：
        1.顺序查找：从头到尾逐个遍历与表中元素一一比较  [时间复杂度 O(n)]                      适合无序数据，数据量小
        2.二分查找：升序/降序数据，对半查找           [时间复杂度 O(logN)]   n/(2^k) = 1     适合有序数据，数据量大
        3.哈希查找：根据哈希函数找到对应的关键字       [时间复杂度 O(1)]                      需要额外空间，高效查询  

    排序：
        1.直接插入排序：依次比较，找到合适位置插入            [时间复杂度 O(n)] 
        2.冒泡排序：相邻元素比较交换位置                     [时间复杂度 O(n^2)]
        3.简单选择排序：找到最小元素与待排区第一个元素交换      [时间复杂度 O(n^2)]

        3.希尔排序：
        4.快速排序：{
            1'分治策略，先从数列中取出一个数作为基准数
            2'分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边
            3'再对左右区间重复第二步，直到各区间只有一个数    
            [时间复杂度最好最坏 O(nlgn)和 O(n^2)]
        }
        5.堆排序：{
            1'找出最后一个非叶子节点，自下而上，前提：完全二叉树
            2'逐个提取堆顶最大值，最大值与父节点比较交换，确保父节点 ≥ 子节点
            3'开始排序，交换堆顶(Max)和末尾 -> 重新步骤2构建最大堆 -> 交换堆顶(Max)和(末尾-1)
            [
                构建最大堆   时间复杂度O(n)
                排序堆调整   时间复杂度O(logN) <= 树高
                总体        时间复杂度O(N logN)   O(N logN) 是主导项，O(n)忽略不计  
            ]
        }
        6.并归排序：{
            1'分治法，持续切割为最小二单位
            2'逐步比较最小二单位，比较交互位置
            3'合并左右单位，核心思想{ 给左右两个数组分别设定一个标记符号i和j，通过比对当前i和j位置的数的大小，选择小的值加入到最后的结果中 }
            [时间复杂度  O(N logN)]
            {
                示例计算：
                left = [2, 5, 7] 和 right = [1, 3, 6]     指针 i = 0（指向 left 的起始位置）。
                                                          指针 j = 0（指向 right 的起始位置）。
                                                          空结果数组 merged = []。

                Step 1：left[0] = 2 vs right[0] = 1 → 1 更小 → merged = [1]，j++。
                Step 2：left[0] = 2 vs right[1] = 3 → 2 更小 → merged = [1, 2]，i++。
                Step 3：left[1] = 5 vs right[1] = 3 → 3 更小 → merged = [1, 2, 3]，j++。
                Step 4：left[1] = 5 vs right[2] = 6 → 5 更小 → merged = [1, 2, 3, 5]，i++。
                Step 5：left[2] = 7 vs right[2] = 6 → 6 更小 → merged = [1, 2, 3, 5, 6]，j++。
                Step 6：right 已遍历完，将 left 剩余元素（[7]）直接追加 → merged = [1, 2, 3, 5, 6, 7]。
                
                Merge操作：[时间复杂度 O(n)  空间复杂度：O(n)]
            }
        }
```


```
1计算机系统知识

    五大组成部件：{
        运算器：负责算术运算和逻辑运算
        控制器：指挥中心，从内存读取指令，译码，产生执行该指令所需的控制信号
        存储器：用于存储程序指令、数据 {
            主储存器：内存，速度快，容量小，断电丢失（易失性），RAM [操作系统管理]
            外储存器：外存，速度慢，容量大，断电后数据不丢失（非易失性），硬盘、SSD固态、U盘 [操作系统/用户管理]
            Cache：超快，超小，存放CPU马上要用的指令和数据 [硬件管理]
            
            在冯·诺依曼结构中，“存储器”主要指内存。CPU只能直接访问内存
        }
        输入设备：将外部信息指令输入计算机，键盘、鼠标、麦克风
        输出设备：将计算机信息以人能感知的方式呈现，显示器、耳机、打印机

        运算器 + 控制器 = CPU
        CPU   + 储存器 = 主机
    }

    中央处理器CPU：{
        运算器：{
            算术逻辑单元 ALU：核心计算单元，负责算术运算和逻辑运算
            累加寄存器 ACC：暂存 ALU 的运算操作数和运算结果
            数据缓冲寄存器 DR：暂存放内存指令和数据
            状态条件寄存器 PSW：存放运算结果的状态信息，如进位标志(C)、溢出标志(O)、零标志(Z)等。这些状态是程序分支判断（如if语句）的依据
        }
        控制器：{
            程序计数器 PC：！存放下一条要执行指令的内存地址，CPU每取出一条，计数+1
            指令寄存器 IR：存放当前执行中的指令本身
            指令译码器 ID：分析IR指令，确定指令的操作和操作数地址
            地址寄存器 AR：保存当前CPU访问的内存单元地址 [是读或写的数据的内存地址，并非执行指令的内存地址]
            时序发生器：确保各个操作按时序有序进行
        }
        寄存器组：CPU的高速存储单位，用于暂时存放指令、数据和地址，PC、ACC、IR等都属于专用寄存器
    }

    CPU工作过程：不断重复的过程 {
        取指：PC取出 -> 送往IR -> PC值+1 -> 指向下一条执行地址
        译码：ID 识别出指令的 操作码和操作数
        执行：控制器发出信号 [控制单元CU、时序发生器 处理信息的发送]， ALU执行操作
        写回：将执行结果写入到CPU内部的寄存器或内存中
    }

    寄存器：{
        三者协同： {
            1、启动程序：CPU需要处理一个任务（程序），它首先去巨大的“档案室”（外存，如硬盘）里找到这个程序的所有资料。 
            2、加载到办公桌：CPU把这些资料从硬盘全部加载到自己的“办公桌”（内存）上，这样处理起来就快多了。   
            3、贴身秘书预取：CPU处理速度极快，而内存速度跟不上。为了避免CPU“饿着”（空等），一个聪明的“贴身秘书”（Cache）就开始工作。它会预测CPU下一步需要什么资料，提前从“办公桌”（内存）上把那一小部分资料取过来，拿在手里准备着。      
            4、极致效率：当CPU需要下一步数据时，直接从秘书（Cache）手里拿，速度极快。如果秘书猜对了（Cache命中），效率极高；如果猜错了（Cache未命中），再去办公桌（内存）上拿，速度就慢一些。
        }

        局部性原理：提前把内存放到Cache，基于时间局限性（最近使用）和空间局限性（相邻）来预测

        Cache映射方式：内存中的一块数据可以放在Cache的哪个位置 {
            直接相联映射：
                📝 规则：内存中的每一块数据只能被放入Cache中唯一的一个特定位置；Cache行号 = 内存块地址 % Cache总行数
                ✅ 优点：硬件电路简单，查找速度快（只需比较一个标签）
                ❌ 缺点：Cache行号 = 内存块地址 % Cache总行数； 冲突率高，容易发生抖动，Cache命中率急剧下降
                💡 比喻：一栋楼有100个房间（Cache行），你的座位（内存块）在哪一房间是固定的（比如用工号%100决定）。如果两个人（内存块）被分到同一个房间，就只能轮流使用

            全相联映射：
                📝 规则：内存中的每一块数据只能被放入Cache中的任意一个位置
                ✅ 优点：冲突率最低，Cache空间利用率高
                ❌ 缺点：硬件成本极高，查找麻烦
                💡 比喻：一个开放式大办公室（Cache），你可以随便选任何一个空位子坐。但保安（Cache控制器）找你时，需要挨个查看所有座位才能找到你，很慢

            组相联映射：
                📝 规则：折中方案，将Cache分成若干组(Set)，每组包含多行(Way)。内存块映射到特定的组，但可以放入该组内的任意一行；组号 = 内存块地址 % 总组数
                ✅ 优点：当前最主流的映射方式
                💡 比喻：大楼有50个组（Set），每个组有2个房间（2-Way）。你的座位在哪个组是固定的，但组内的两个房间你可以任选一个空的使用。保安找你时，只需要在你所在的那个组里查2个房间即可，又快又好
        }

        Cache命中率计算：命中率 (H) = 命中次数 / 总访问次数；未命中率 (M) = 1 - 命中率
        平均访问时间： H * Tc（Cache访问时间） + M * Tm（内存访问时间）
    }

    指令系统：{
        RISC：Reduced，ARM，指令数少，指令简单，长度固定，大多数单周期
        CISC：Complex，Intel，指令数多，指令复杂，长度可变，多周期
    }
```

```txt
{
    黑盒测试：input and output {
        测试阶段：功能测试、系统测试、验收测试
        测试依据：需求设计说明书，用户手册、设计文档
        测试用例设计方法：{
            等价类划分：将输入数据划分为若干等价类，从每个类中选取一个代表值进行测试
            边界值划分：对输入数据的边界值进行测试
            状态迁移图：测试系统在不同状态之间转换时的行为
            因果图：通过分析输入条件（因）和输出结果（果）之间的关系来设计测试用例
        }
    }

    白盒测试：根据代码逻辑设计 {
        测试阶段：单元测试、集成测试
        测试依据：源代码、详细设计文档
        测试用例设计方法：{
            语句覆盖：每条执行语句至少执行一遍
            判定覆盖：每个判断的真假至少执行一遍
            条件覆盖：每个条件至少满足一遍
            判定/条件：同时满足判定覆盖和条件覆盖
            条件组合覆盖：多个条件组合的情况至少满足一遍
            路径覆盖：设计用例覆盖程序中所有可能的执行路径
        }
    }
}
```

```
https://github.com/aquarkgn/Software-Designer/tree/master/Markdown%E7%89%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86

https://github.com/xiaomabenten/software_designer

https://github.com/luckyzhz/Software-Designer
```